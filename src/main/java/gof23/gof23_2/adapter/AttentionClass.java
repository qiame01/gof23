package gof23.gof23_2.adapter;

/**
 * <p>
 * 适配器模式作用：适配器类，通过继承/实现/继承目标抽象类/接口/具体类Target，并组合/继承一个Adaptee对象，使二者产生联系
 * 适配器模式使用时机：想要使两个不相干的类在一起工作
 * 适配器模式分为两类三种
 * <p>
 * 第一类包含两种：类适配器模式、对象适配器模式。它们具有如下相同的角色和运行流程
 * 角色和结构：用户、适配器类Adapter、被适配类Adaptee、被适配器类继承/实现/继承的目标抽象类/接口/具体类Target
 * 运行流程：1用户实例化适配器类对象，并调用其方法A（继承/实现/重写自Target），2A中必须调用被适配类的方法B，并进行二次加工后返回
 * 区别：运行流程中第二步，如何才能调用到原方法？有组合和继承两种方式。组合——对象适配器，继承——类适配器
 * <p>
 * 第二类包含一种：缺省适配器模式，是适配器模式的一种变体，应用广泛
 * 详解：当不需要实现一个接口所有方法时，可先设计一个(抽象)类实现该接口，类中为每个方法提供默认实现（空方法），则子类可选择性地覆盖父类某些方法来实现需求
 * 角色和结构：接口C、空实现类A，A的子类B（B只需重写A的部分方法即可，B可以是匿名内部类或有名，B中可以组合其他对象）
 * 运行流程：用户创建子类B对象（匿名或有名均可），并调用其方法
 * <p>
 * 推荐：由于继承——类适配器具有单继承缺陷，TODO 故推荐使用对象适配器模式。另外缺省适配器模式也很常用
 */
public class AttentionClass {}
